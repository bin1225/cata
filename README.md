# 숫자야구 게임 Cata

'객체지향의 사실과 오해'를 읽으며 자율적인 객체의 중요성을 알았다.
그리고 메시지를 기반으로 설계한다면 보다 자연스럽게 객체지향스러운 코드를 작성할 수 있음을 알았다. 이러한 부분에 초점을 맞춰 숫자야구 게임을 간단하게 구현해보려고 노력했다.

## 기능 목록
* 임의의 서로 다른 숫자 3개를 선정한다.
  * 숫자는 1~10 사이의 자연수이다.


* 숫자 3개를 사용자로부터 입력 받는다.
  * 서로 다른 숫자가 아닌 경우 다시 입력받는다.
  * 범위를 초과한 경우 다시 입력받는다.
  * 이외에도 요구하는 입력값이 아니면 다시 입력받는다.
  


* 입력받은 숫자와 선정된 숫자를 비교하여 결과를 출력한다.
  * 일치하는 숫자가 존재하는 경우 볼
  * 숫자와 자리가 모두 일치하는 경우 스트라이크


* 사용자가 정답을 맞출 때까지 입력과 힌트 출력을 반복한다.

태그 : 제목의 형태이며, :뒤에만 space가 있음에 유의한다.

---
## 고민해본 것
### 테스트를 위한 구조변경이 필요한가?
숫자 비교 기능을 구현하고 관련 테스트를 작성하는 도중 문제가 생겼다.

`Computer` 객체에 랜덤으로 생성한 정답숫자를 필드 변수로 저장했다. 이후 비교하는 기능의 수행은 정담 숫자를 가지고 있는 `Computer` 객체가 맡는 것이 좋겠다고 생각했다. 문제는 해당 기능을 테스트할 때 정답 숫자를 조정할 수 없다는 것이다.

숫자는 랜덤으로 생성된다. 스트라이크와 볼이 나오는 경우들을 모두 테스트해보기 위해서는 정답 숫자를 설정하고 비교하는 것이 필요한데, 매개변수로 비교 대상 `guessNumber`만 받는 경우에는 이게 복잡해진다.
임의로 생성된 숫자를 직접 조작해서 변경해야하는데, 이정도면 테스트에 대한 테스트도 필요할 것 같단 생각이 들었다.

따라서 `guessNumbers`와 `expectNumbers`를 모두 받도록 하여, 테스트메서드에서 임의로 배열을 선언하고 비교하도록 하였다. 불필요한 매개변수를 테스트 코드를 위해 사용하는 것이 맞는지 모르겠다.

### 가독성과 효율성
1. 가독성
```java
while(expectNumbers.equals(inputNumbers)){
    Hint hint = computer.compareNumbers(expectNumbers, inputNumbers);
    Output.printHint(hint);
    inputNumbers = Input.getThreeNumber();
}
```
2. 효율성
```java
while(true){
    Hint hint = computer.compareNumbers(expectNumbers, inputNumbers);
    if(hint.getStrike() == GameConfiguration.BALL_SIZE) break;
    Output.printHint(hint);
    inputNumbers = Input.getThreeNumber();
}
```
전자는 매 반복시마다 `inputNumbers`와 `expectNumbers`를 비교한다. 후자는 `hint`에 저장된 strike 정보를 가져와서 종료조건을 확인한다.
현재 컴퓨터 하드웨어에서 저정도 길이의 배열을 비교하는 것은 속도 차이가 없다고 봐도 무방하다. 하지만 배열의 길이가 유의미한 속도차이를 낼만큼 길다면 어떻게 해야할까. 후자의 경우 객체지향의 캡슐화를 조금 깬다. `strike`에 대한 정보를 불필요하게 외부에 노출하는 느낌이 있다. 또 코드 자체에 대한 가독성도 1번보다 떨어진다고 생각한다.

### 검증의 책임을 담당하는 객체
사용자로부터 입력을 받는 `Input`객체와 입력받은 값에 대한 검증을 수행하는 `InputValidator` 객체를 구성하여 입력값을 받았다.

이때 입력을 받는 수가 숫자인지에 대한 검증은 `Input`클래스에서 `scanner.nextInt()`로 입력을 받으며 검증하도록 하였다. 
`String` 형태로 받아 `InputValidator`에서 숫자인지에 대한 검증도 수행하고, 해당 수의 조건들도 확인하는 게 맞는지 모르겠다.

입력 자체에 대한 검증은 `Input`에서 하는 게 맞다고 생각했다. 또 `nextInt()`로 라이브러리 함수를 이용해 숫자인지를 검증하고 변환하는 것이 더 코드가 안정적일 것 같았다.


### 깃커밋
솔직히 커밋 귀찮고 어렵다. 애매한 부분이 계속 생기는 것 같다. 

1. 사소한 오타나 메시지명 변경 하나하나 단위로 커밋을 하는 게 맞는가.
2. 한 번의 기능 구현에서 여러가지 부분의 커밋사항이 있다면 어떤 방식으로 커밋해야하는가
-> 특정 기능을 구현하는 도중 기존 구현사항의 문제점이 있어 동시에 고치고 기능을 추가했다면?
3. 주객전도되는 느낌이다. 구현에 몰두하다보면 여러가지 변경사항들이 맞물리게 되는데, 무엇을 먼저 커밋해야할지. 어떻게 나눠서 커밋해야할지 복잡하다.

---

## 배운 것
이전에 우아한테크코스의 프리코스 과제로 진행할 때는 `Strike`와 `Ball`에 대한 정보를 출력하기 위해 `Output`에서 `getter`메서드를 호출해 해당 정보를 가져와 출력했다.
이 과정에서 해당 객체의 상태값이 외부에 노출돼어 강하게 결합하고 객체의 자율성이 떨어진다. 

이번 구현에서는 `Hint`라는 객체를 선언해서 `strike`와`ball`에 대한 정보를 저장했다. 여기서 `toString`메서드를 오버라이드 해서 `strike`와`ball`에 대한 정보를 외부에 노출하지 않고, 메시지를 생성할 수 있도록 하였다.

객체간 결합이 약해지고 조금 더 객체지향스러운 코드라고 생각한다.
```java
    @Override
    public String toString() {
        if (strike == 0 && ball == 0) {
            return "낫싱";
        } else if (strike == 0) {
            return ball + " 볼";
        } else if (ball == 0) {
            return strike + " 스트라이크";
        } else {
            return strike + " 스트라이크 " + ball + " 볼";
        }
    }
```

---
#### 커밋 컨벤션

* `feat` : 새로운 기능 추가
* `fix` : 버그 수정
* `docs` : 문서 수정
* `style` : 코드 포맷팅, 세미콜론 누락, 코드 변경이 없는 경우
* `refactor` : 코드 리펙토링
* `test` : 테스트 코드, 리펙토링 테스트 코드 추가
* `chore` : 빌드 업무 수정, 패키지 매니저 수정
